---
title: "scAML_embedding"
format: gfm
editor: visual
bibliography: references.bib
---

# Introduction

To get some first experience with multimodal single cell data, we use the data set generated by [@granja2019]. In this studies, authors generated multimodal data including combined scRNA- and surface epitopes (CITE-seq) and scATAC seq data from healthy donor peripheral blood (PBMCs) and bone marrow mononuclear cells (BMMCs) and CD34+ enriched BMMCs. CITE-seq data was integrated and used to generate a reference map for healthy hematopoiesis. Furthermore, they used scATAC-seq to generate a reference epigenetic map of healthy hematopoiesis.

They tested the robustness and generalizability of the reference map by iteratively projection various data sets of healthy bone marrow subcompartements onto the map always confirming high agreement in subtype projection and identification.

Building on this multimodal reference map they then profile PB/BMMCs from 6 distinct patients with mixed-phenotype acute leukemia (MPAL), project this data set into the reference map and investigate associations to non-malignent cellular counterparts, differentially expressed peaks, TFs and compared them to other published single-cell leukemia data sets.

With this vignette we'll try to

1.  load the scRNA- and scATAC-seq data from the healthy samples
2.  create an seurat object and perform basic quality controls, filtering etc.
3.  perform a multimodal integration of scRNA and scATAC-seq
4.  project the MPAL data into the WNN-graph
5.  use IReNA to construct GRNs

For steps 1-4, since they are well standardized, we'll work with the seurat vignette.

# Results

## scRNA-seq

### Loading, Filtering

The GEO data set includes scRNA-seq data BMMCs, CD34+ BMMCs, PBCMs and 6 MPAL samples of which two are first diagnosis and relapse from the same patient.

scRNA-seq data are stored as a sparse matrix

```{r}
BMMC1.scRNA <- readRDS("datasets/granja_scMPAL/GSM4138872_scRNA_BMMC_D1T1.rds")
BMMC2.scRNA <- readRDS("datasets/granja_scMPAL/GSM4138873_scRNA_BMMC_D1T2.rds")
CD34_1.scRNA <- readRDS("datasets/granja_scMPAL/GSM4138874_scRNA_CD34_D2T1.rds")
CD34_2.scRNA <- readRDS("datasets/granja_scMPAL/GSM4138875_scRNA_CD34_D3T1.rds")
PBMC1.scRNA  <- readRDS("datasets/granja_scMPAL/GSM4138876_scRNA_PBMC_D4T1.rds")
PBMC2.scRNA <- readRDS("datasets/granja_scMPAL/GSM4138877_scRNA_PBMC_D4T2.rds")
```

Both objects include 20287 rows (=transcripts) from \~ 35000 single cells (identified by a common prefix (in this case "BMMC_D1T2:") and a cell UMI. The first goal would be to get this data into an seurat object.

```{r}
str(BMMC1.scRNA)
```

SeuratObject includes a CreateSeuratObject wrapper which takes 10x CellRanger input. Merging two 10x runs into a single seurat object is described [here](https://satijalab.org/seurat/articles/merge_vignette.html).

```{r}
library(Seurat)
library(dplyr)


BMMC1.scRNA.seurat <- CreateSeuratObject(counts = BMMC1.scRNA,project = "BMMC1.scRNA", assay = "RNA", names.field = 2, names.delim = ":")

BMMC2.scRNA.seurat <- CreateSeuratObject(counts = BMMC2.scRNA,project = "BMMC2.scRNA", assay = "RNA", names.field = 2, names.delim = ":")

CD34_1.scRNA.seurat <- CreateSeuratObject(counts = CD34_1.scRNA,project = "CD34_1.scRNA", assay = "RNA", names.field = 2, names.delim = ":")

CD34_2.scRNA.seurat <- CreateSeuratObject(counts = CD34_2.scRNA,project = "CD34_2.scRNA", assay = "RNA", names.field = 2, names.delim = ":")

PBMC1.scRNA.seurat <- CreateSeuratObject(counts = PBMC1.scRNA,project = "PBMC1.scRNA", assay = "RNA", names.field = 2, names.delim = ":")

PBMC2.scRNA.seurat <- CreateSeuratObject(counts = PBMC2.scRNA,project = "PBCM2.scRNA", assay = "RNA", names.field = 2, names.delim = ":")



scRNA.seurat <- merge(BMMC1.scRNA.seurat, y = c(BMMC2.scRNA.seurat, CD34_1.scRNA.seurat, CD34_2.scRNA.seurat, PBMC1.scRNA.seurat, PBMC2.scRNA.seurat), add.cell.ids = c("BMMC1", "BMMC2", "CD34_1", "CD34_2", "PBMC1", "PBMC2"), project = "MPAL.scRNA")
```

Lets have a first glimpse into out newly generated seurat object. We can access the assays data by using \[\["assay"\]\].

```{r}
glimpse(head(scRNA.seurat[["RNA"]]@counts, 5))
```

Some cell-wise meta data is automatically calculated during the creation of the seurat object.

```{r}
head(scRNA.seurat@meta.data, 5)
```

Basic metrics include number of total counts per cell (nCount_RNA) and number of non-zero features (nFeature_RNA) per cell. This helps to identify cells with very low (\<200) or very high (\>25.000) unique features, the former being dead and the latter duplicated cells. In principal, we could identify cells with high (\>5%) mitochondrial counts which is also a feature of low-quality samples by adding a new meta data column. However, mitochondrial and ribosomal genes were already filtered out by the authors.

```{r}
rownames(scRNA.seurat) %>% grepl(pattern = "^MT-") %>% any()
```

```{r}
scRNA.seurat[["percent.mt"]] <- PercentageFeatureSet(scRNA.seurat, pattern = "^MT-")

VlnPlot(scRNA.seurat, features = c("nCount_RNA", "nFeature_RNA", "percent.mt"))
```

```{r}
FeatureScatter(scRNA.seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

The authors set the QC filtering threshold to remove cells with less than 400 detected genes (features) and less than 1000 counts (UMIs) as well as above 10.000 counts (UMIs). As shown by the violin plot, this filtering was already applied to the data set.

```{r}
scRNA.seurat <- subset(scRNA.seurat, nFeature_RNA > 400 & nCount_RNA > 1000 & nCount_RNA < 10000)
```

### Normalization

The default normalization of scaling to 10.000 depth followed by log2 (n+1) normalization was also used by the authors in the manuscript.

```{r}
scRNA.seurat <- NormalizeData(scRNA.seurat, normalization.method = "LogNormalize", scale.factor = 1000)
```

### Variable Feature Detection and PCA

We detect the top 3000 most variable features (genes) to later use as input for dimensionality reduction and visualization

```{r}
scRNA.seurat <- FindVariableFeatures(scRNA.seurat, selection.method = "vst", nfeatures = 3000)
```

```{r}
VariableFeatures(scRNA.seurat) %>% head(20)
```

We next scale feature-wise to make sure that gene expression is not the main driver of variance. We scale all features instead of only the 3000 most variable ones.

```{r}
scRNA.seurat <- ScaleData(scRNA.seurat, features = rownames(scRNA.seurat))
```

The scaled data matrix can be accessed

```{r}
scRNA.seurat[["RNA"]]@scale.data[1:10, 1:10]
```

```{r}
scRNA.seurat <- RunPCA(scRNA.seurat, features = VariableFeatures(scRNA.seurat))
```

```{r}
DimPlot(scRNA.seurat, reduction = "pca")
```

### Determining Data Set Dimensionality

```{r}
scRNA.seurat <- JackStraw(scRNA.seurat, num.replicate = 100, dims = 100)
```

```{r}
scRNA.seurat <- ScoreJackStraw(scRNA.seurat, dims = 1:50)
```

```{r}
JackStrawPlot(scRNA.seurat, dims = 1:50)
```

From the jackstraw plot it appears that PCs 1:45 are the most informative.

```{r}
ElbowPlot(scRNA.seurat, ndims = 50)
```

### Visualization

First, we identify clusters/communities based on the KNN graph.

```{r}
scRNA.seurat <- FindNeighbors(scRNA.seurat, dims = 1:45)
scRNA.seurat <- FindClusters(scRNA.seurat, resolution = 0.3)
```

And visualize the data set using UMAP

```{r}

cols = DiscretePalette(n = 25)

scRNA.seurat <- RunUMAP(scRNA.seurat, dims = 1:50, n.neighbors = 35, min.dist = 0.45)
DimPlot(scRNA.seurat, reduction = "umap", cols = cols)
```

### Find Marker Genes

We can use the seurat function FindAllMarkers to identify the top DE markers per any of the cluster compared to all other cells. We can further filter these to only show the top up-regulated ones.

### Label annotation

```{r}
scRNA.cluster_markers <- FindAllMarkers(scRNA.seurat, only.pos = T, min.pct = 0.25, logfc.threshold = 0.25)


```

Semi-automatic cell type annotation is performed using [SingleR](https://bioconductor.org/packages/devel/bioc/vignettes/SingleR/inst/doc/SingleR.html) and the [celldex](https://bioconductor.org/packages/3.17/data/experiment/html/celldex.html) reference sets.

A brief description of the SingleR method from the book

[*SingleR*](https://bioconductor.org/packages/3.17/SingleR) can be considered a robust variant of nearest-neighbors classification, with some tweaks to improve resolution for closely related labels. For each test cell:

1.  We compute the Spearman correlation between its expression profile and that of each reference sample. The use of Spearman's correlation provides a measure of robustness to batch effects across datasets. The calculation only uses the union of marker genes identified by pairwise comparisons between labels in the reference data, so as to improve resolution of separation between labels.

2.  We define the per-label score as a fixed quantile (by default, 0.8) of the correlations across all samples with that label. This accounts for differences in the number of reference samples for each label, which interferes with simpler flavors of nearest neighbor classification; it also avoids penalizing classifications to heterogeneous labels by only requiring a good match to a minority of samples.

3.  We repeat the score calculation for all labels in the reference dataset. The label with the highest score is used as [*SingleR*](https://bioconductor.org/packages/3.17/SingleR)'s prediction for this cell.

4.  We optionally perform a fine-tuning step to improve resolution between closely related labels. The reference dataset is subsetted to only include labels with scores close to the maximum; scores are recomputed using only marker genes for the subset of labels, thus focusing on the most relevant features; and this process is iterated until only one label remains.

For our data set including mainly peripheral and bone marrow derived myeloid cells, the Noversthern and BLUEPRINT reference maps seems to be the best choice. To harmonize labels we stick to the [cell ontology](http://bioconductor.org/books/devel/SingleRBook/exploiting-the-cell-ontology.html) labels.

```{r}
ref_noversht <- celldex::NovershternHematopoieticData(cell.ont = "nonna")
ref_blueprint <- celldex::BlueprintEncodeData(cell.ont = "nonna")

library(SummarizedExperiment)


cell_ontology <- ontoProc::getCellOnto()

colData(ref_blueprint) %>% 
  as_tibble() %>% 
  distinct(label.fine, .keep_all = T) %>% 
  mutate(cell_ont = cell_ontology$name[label.ont])

colData(ref_noversht) %>% 
  as_tibble() %>% 
  distinct(label.fine, .keep_all = T) %>% 
  mutate(cell_ont = cell_ontology$name[label.ont])



```

We can either get cell- or cluster-specific labels. The SingleR vignette recommends using the cell-level instead of the cluster-level assignments due to its much higher information content.

```{r}
SingleR::SingleR(test = GetAssayData(scRNA.seurat), ref = list(ref_noversht, ref_blueprint), labels = list(ref_noversht$label.ont, ref_blueprint$label.ont), de.method = "classic") -> scRNA.singleR_cell_labels

# add the cell-level labels as ontology terms
scRNA.seurat[["SingleR.cell_labels"]] <- scRNA.singleR_cell_labels$pruned.labels

# and as clearnames
scRNA.seurat[["SingleR.cell_labels.clearname"]] <- cell_ontology$name[scRNA.singleR_cell_labels$pruned.labels]


SingleR::SingleR(test = GetAssayData(scRNA.seurat), ref = list(ref_noversht, ref_blueprint), clusters = Idents(scRNA.seurat),labels = list(ref_noversht$label.ont, ref_blueprint$label.ont)) -> scRNA.singleR_cluster_labels

scRNA.singleR_cluster_labels %>% 
  as_tibble(rownames = "cluster") %>% 
  dplyr::select(cluster, pruned.labels) %>% 
  deframe() -> cluster_to_ontology
  
# also add the cluster-level labels
scRNA.seurat[["SingleR.cluster_labels"]] <- cluster_to_ontology[Idents(scRNA.seurat)]

# and the cluster-level clearnames
scRNA.seurat[["SingleR.cluster_labels.clearname"]] <- cell_ontology$name[cluster_to_ontology[Idents(scRNA.seurat)]]
```

First, we can plot a histrogram of the per-cell label scores

```{r}
scRNA.singleR_cell_labels %>% 
  SingleR::plotScoreHeatmap()
```

This heatmap gives a feeling for the in-label uncertainty. Hence for every label (column) we can investigate the spread of the scores with a very broad spread suggesting low certainty in the label assignment (in this case high certainty in myeloid cells and lower certainty within the T-cell compartments).

Label pruning takes into considerations labels with scores below a delta threshold where delta is defined as the difference between the highest score (e.g. the "correct"/matching label) and the median score (the non-matching label). We can see how many labels are removed after pruning by comparing the number of primary to empty pruned labels.

```{r}
scRNA.singleR_cell_labels %>% 
  as_tibble() %>% 
  {
    table(.$labels, is.na(.$pruned.labels))
  }
```

Finally, we can visualize the per label score distribution and also the delta threshold used for pruning

```{r}
SingleR::plotDeltaDistribution(scRNA.singleR_cell_labels)
```

Another interesting aspect is to compare the cell-specific labels to the results of the unsupervised clustering. It seems reasonable to assume that labels should be a main driver of variance and hence within cluster labels should be quite similar while between cluster labels should not. This aspect can be formally tested using the the adjusted rand index (ARI) which calculates the "agreement" of within cluster cell labels. Generally, an ARI \> 0.5 is interpreted as good cluster agreement.

```{r}
bluster::pairwiseRand(Idents(scRNA.seurat), scRNA.singleR_cell_labels$pruned.labels, mode = "index")
```

Finally, we can plot a heatmap comparing the per cluster labels.

```{r}
log10(table(Idents(scRNA.seurat), scRNA.seurat$SingleR.cell_labels.clearname)+10) %>% 
  t() %>% 
  ComplexHeatmap::Heatmap()
```

And the cell-level to the cluster-level labels

```{r}
log10(table(scRNA.seurat$SingleR.cell_labels.clearname, scRNA.seurat$SingleR.cluster_labels.clearname)+10) %>% 
  ComplexHeatmap::Heatmap()
```

As we can see, in general there's a very good agreement between the cell-level and cluster-level assignments; however, within the unsupervised clusters, there's considerable heterogeneity in cell types.

```{r}
DimPlot(scRNA.seurat, reduction = "umap", label = T, group.by = "SingleR.cluster_labels.clearname", cols = DiscretePalette(n = unique(scRNA.seurat$SingleR.cluster_labels.clearname) %>% length()))
```

# Saving/Loading HDF5

```{r}
SeuratDisk::SaveH5Seurat(scRNA.seurat, overwrite = T)
rm(scRNA.seurat)
scRNA.seurat <- SeuratDisk::LoadH5Seurat(file = "MPAL.scRNA.h5Seurat")
```
